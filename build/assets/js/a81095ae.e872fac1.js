"use strict";(globalThis.webpackChunkeducational_ai_humanoid_robotics=globalThis.webpackChunkeducational_ai_humanoid_robotics||[]).push([[123],{6933:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>p});const o=JSON.parse('{"id":"humanoid-robotics/walking-algorithms","title":"Humanoid Robot Walking Algorithms and Gait Generation","description":"Overview","source":"@site/docs/humanoid-robotics/walking-algorithms.md","sourceDirName":"humanoid-robotics","slug":"/humanoid-robotics/walking-algorithms","permalink":"/educational-ai-humanoid-robotics/docs/humanoid-robotics/walking-algorithms","draft":false,"unlisted":false,"editUrl":"https://github.com/educational-ai-humanoid-robotics/educational-ai-humanoid-robotics.github.io/tree/main/packages/create-docusaurus/templates/shared/docs/humanoid-robotics/walking-algorithms.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Control Systems for Humanoid Robots","permalink":"/educational-ai-humanoid-robotics/docs/humanoid-robotics/control-systems"},"next":{"title":"Human-Robot Interaction for Social Robotics","permalink":"/educational-ai-humanoid-robotics/docs/humanoid-robotics/human-robot-interaction"}}');var i=t(4848),a=t(8453);const r={sidebar_position:4},s="Humanoid Robot Walking Algorithms and Gait Generation",l={},p=[{value:"Overview",id:"overview",level:2},{value:"Fundamentals of Bipedal Locomotion",id:"fundamentals-of-bipedal-locomotion",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Phases of Walking",id:"phases-of-walking",level:3},{value:"Linear Inverted Pendulum Model (LIPM) for Walking",id:"linear-inverted-pendulum-model-lipm-for-walking",level:2},{value:"Preview Control for Walking",id:"preview-control-for-walking",level:2},{value:"Capture Point-Based Walking",id:"capture-point-based-walking",level:2},{value:"Advanced Walking Patterns",id:"advanced-walking-patterns",level:2},{value:"Dynamic Walking with Momentum",id:"dynamic-walking-with-momentum",level:3},{value:"Walking Pattern Visualization",id:"walking-pattern-visualization",level:2},{value:"Walking Stability Metrics",id:"walking-stability-metrics",level:2},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2}];function _(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"humanoid-robot-walking-algorithms-and-gait-generation",children:"Humanoid Robot Walking Algorithms and Gait Generation"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Walking is one of the most fundamental and challenging capabilities for humanoid robots. The complexity arises from the need to maintain dynamic balance while transferring weight from one foot to another, all while navigating potentially complex environments. This section explores the mathematical foundations, implementation approaches, and practical considerations for humanoid walking algorithms."}),"\n",(0,i.jsx)(n.h2,{id:"fundamentals-of-bipedal-locomotion",children:"Fundamentals of Bipedal Locomotion"}),"\n",(0,i.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsx)(n.p,{children:"Humanoid walking involves several fundamental concepts that distinguish it from other forms of locomotion:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Balance"}),": Unlike wheeled or static robots, humanoid robots must actively maintain balance during walking."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Zero Moment Point (ZMP)"}),": The point where the moment of the ground reaction force is zero, crucial for stability."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Capture Point"}),": The location where a robot should step to stop its current CoM motion."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Support Polygon"}),": The area defined by the robot's points of contact with the ground."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"phases-of-walking",children:"Phases of Walking"}),"\n",(0,i.jsx)(n.p,{children:"Humanoid walking typically consists of several distinct phases:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Double Support Phase"}),": Both feet are on the ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Support Phase"}),": Only one foot is on the ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Swing Phase"}),": The free foot moves forward"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Preparation Phase"}),": Adjusting stance before stepping"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom math import sin, cos, pi, sqrt\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\n\nclass WalkingPhase:\n    DOUBLE_SUPPORT = 0\n    LEFT_STANCE = 1\n    RIGHT_STANCE = 2\n    LEFT_SWING = 3\n    RIGHT_SWING = 4\n\nclass WalkingPatternGenerator:\n    def __init__(self, com_height=0.85, step_length=0.3, step_duration=1.0):\n        self.com_height = com_height  # Center of mass height (m)\n        self.step_length = step_length  # Forward step length (m)\n        self.step_duration = step_duration  # Total time per step (s)\n        self.gravity = 9.81  # Gravity constant\n        self.omega = sqrt(self.gravity / self.com_height)  # Natural frequency parameter\n        \n        # Gait timing parameters\n        self.ds_duration = 0.1 * self.step_duration  # Double support duration (10% of step time)\n        self.ss_duration = (self.step_duration - self.ds_duration) / 2  # Single support duration per foot\n        \n        # Foot placement parameters\n        self.step_width = 0.2  # Lateral step width (m)\n        self.step_height = 0.1  # Maximum swing foot height (m)\n        \n    def generate_walking_pattern(self, n_steps=10, walking_direction="forward"):\n        """\n        Generate complete walking pattern for n steps\n        \n        Args:\n            n_steps: Number of walking steps to generate\n            walking_direction: "forward", "backward", "sideways", "turn"\n            \n        Returns:\n            Dictionary containing CoM and foot trajectories\n        """\n        total_time = n_steps * self.step_duration\n        dt = 0.01  # 100 Hz control rate\n        time_points = np.arange(0, total_time, dt)\n        \n        # Initialize trajectory arrays\n        com_x = np.zeros_like(time_points)\n        com_y = np.zeros_like(time_points)\n        com_z = np.full_like(time_points, self.com_height)  # Approximately constant CoM height\n        \n        # Foot trajectories\n        left_foot_x = np.zeros_like(time_points)\n        left_foot_y = np.zeros_like(time_points)\n        left_foot_z = np.zeros_like(time_points)\n        \n        right_foot_x = np.zeros_like(time_points)\n        right_foot_y = np.zeros_like(time_points)\n        right_foot_z = np.zeros_like(time_points)\n        \n        # ZMP trajectory (for balance monitoring)\n        zmp_x = np.zeros_like(time_points)\n        zmp_y = np.zeros_like(time_points)\n        \n        # Generate pattern for each step\n        for step_idx in range(n_steps):\n            step_start_time = step_idx * self.step_duration\n            step_end_time = (step_idx + 1) * self.step_duration\n            \n            # Determine step parameters based on walking direction\n            if walking_direction == "forward":\n                target_x = step_idx * self.step_length\n                target_y = 0.0\n            elif walking_direction == "backward":\n                target_x = -step_idx * self.step_length\n                target_y = 0.0\n            elif walking_direction == "sideways":\n                target_x = 0.0\n                target_y = step_idx * self.step_width\n            else:  # forward by default\n                target_x = step_idx * self.step_length\n                target_y = 0.0\n            \n            # Generate CoM trajectory for this step\n            step_times_mask = (time_points >= step_start_time) & (time_points < step_end_time)\n            step_relative_time = time_points[step_times_mask] - step_start_time\n            \n            # Generate CoM trajectory using 5th order polynomial (smooth transitions)\n            com_x[step_times_mask] = self.generate_com_trajectory(\n                step_relative_time, \n                step_phase=step_idx % 2,  # Alternate between left and right support\n                step_length=self.step_length\n            )\n            \n            # Generate foot trajectories for this step\n            left_foot_x[step_times_mask], left_foot_y[step_times_mask], left_foot_z[step_times_mask] = \\\n                self.generate_foot_trajectory(\n                    time=step_relative_time,\n                    foot="left",\n                    current_step=step_idx,\n                    target_position=[target_x, target_y]\n                )\n                \n            right_foot_x[step_times_mask], right_foot_y[step_times_mask], right_foot_z[step_times_mask] = \\\n                self.generate_foot_trajectory(\n                    time=step_relative_time,\n                    foot="right",\n                    current_step=step_idx,\n                    target_position=[target_x, target_y]\n                )\n        \n        # Calculate ZMP from CoM trajectory\n        com_vel_x = np.gradient(com_x, dt)\n        com_vel_y = np.gradient(com_y, dt)\n        com_acc_x = np.gradient(com_vel_x, dt)\n        com_acc_y = np.gradient(com_vel_y, dt)\n        \n        zmp_x = com_x - (self.com_height / self.gravity) * com_acc_x\n        zmp_y = com_y - (self.com_height / self.gravity) * com_acc_y\n        \n        return {\n            \'time\': time_points,\n            \'com_trajectory\': {\n                \'x\': com_x,\n                \'y\': com_y,\n                \'z\': com_z\n            },\n            \'left_foot_trajectory\': {\n                \'x\': left_foot_x,\n                \'y\': left_foot_y,\n                \'z\': left_foot_z\n            },\n            \'right_foot_trajectory\': {\n                \'x\': right_foot_x,\n                \'y\': right_foot_y,\n                \'z\': right_foot_z\n            },\n            \'zmp_trajectory\': {\n                \'x\': zmp_x,\n                \'y\': zmp_y\n            },\n            \'step_times\': [i * self.step_duration for i in range(n_steps)],\n            \'support_polygon\': self.calculate_support_polygon(n_steps)\n        }\n    \n    def generate_com_trajectory(self, time, step_phase, step_length):\n        """\n        Generate CoM trajectory for a single step\n        \n        Args:\n            time: Time array for the current step phase\n            step_phase: 0 for left support, 1 for right support\n            step_length: Forward distance of this step\n            \n        Returns:\n            Array of CoM x-positions during this step\n        """\n        # Use a smooth function for CoM trajectory\n        # The CoM typically moves forward smoothly with slight lateral movement\n        # to maintain balance over the supporting foot\n        \n        # Normalize time within the step (0 to 1)\n        normalized_time = time / self.step_duration\n        \n        # Generate CoM trajectory using 5th order polynomial for smooth acceleration/deceleration\n        # This creates a smooth forward movement from one support to the next\n        \n        # Forward progression\n        forward_progress = self.fifth_order_polynomial(normalized_time, 0, step_length * 0.8)\n        \n        # Lateral movement to maintain balance over support foot\n        if step_phase == 0:  # Left foot support\n            lateral_shift = self.fifth_order_polynomial(normalized_time, -self.step_width, 0.0)\n        else:  # Right foot support\n            lateral_shift = self.fifth_order_polynomial(normalized_time, self.step_width, 0.0)\n        \n        return forward_progress + lateral_shift\n    \n    def fifth_order_polynomial(self, t, start_val, end_val):\n        """\n        Generate a 5th order polynomial trajectory\n        Ensures zero velocity and acceleration at start and end\n        """\n        # 5th order polynomial: s(t) = a\u2080 + a\u2081t + a\u2082t\xb2 + a\u2083t\xb3 + a\u2084t\u2074 + a\u2085t\u2075\n        # Conditions: s(0)=start_val, s(1)=end_val, s\'(0)=0, s\'(1)=0, s\'\'(0)=0, s\'\'(1)=0\n        progress = 6 * t**5 - 15 * t**4 + 10 * t**3\n        return start_val + progress * (end_val - start_val)\n    \n    def generate_foot_trajectory(self, time, foot, current_step, target_position):\n        """\n        Generate trajectory for a foot during a step\n        \n        Args:\n            time: Time array within step\n            foot: "left" or "right"\n            current_step: Current step number\n            target_position: [x, y] where foot should end up\n            \n        Returns:\n            Arrays of x, y, z positions\n        """\n        # Determine if this foot is in swing phase or stance phase\n        step_number = current_step\n        \n        # For alternating steps, left foot is in swing during even-numbered steps for left support\n        # This implementation models alternating walk\n        if foot == "left":\n            # Left foot: support during step 0, 2, 4, ... and swing during 1, 3, 5, ...\n            is_swing = step_number % 2 == 1  # Left foot swings during odd-numbered steps\n        else:  # right foot\n            # Right foot: support during step 1, 3, 5, ... and swing during 0, 2, 4, ...\n            is_swing = step_number % 2 == 0  # Right foot swings during even-numbered steps\n        \n        if not is_swing:\n            # Foot is in stance - minimal movement\n            x_pos = np.full_like(time, target_position[0])\n            y_pos = np.full_like(time, target_position[1])\n            z_pos = np.zeros_like(time)  # Foot on ground\n            \n            # Add slight movement to simulate stance adjustments\n            # Small oscillation to model natural weight shifting\n            if foot == "left":\n                y_offset = -self.step_width / 2\n            else:\n                y_offset = self.step_width / 2\n                \n            # Add small periodic adjustment\n            adjustment = 0.01 * np.sin(4 * pi * time / self.step_duration)\n            y_pos += y_offset + adjustment\n        \n        else:\n            # Foot is in swing phase - follow swinging trajectory\n            x_pos, y_pos, z_pos = self.generate_swing_trajectory(time, foot, target_position)\n        \n        return x_pos, y_pos, z_pos\n    \n    def generate_swing_trajectory(self, time, foot, target_position):\n        """\n        Generate swing phase trajectory for one foot\n        """\n        # Calculate swing phase time normalization\n        t_normalized = np.clip(time / self.step_duration, 0, 1)\n        \n        # Define start and end positions\n        # Foot starts and ends at ground level (z=0), reaches max height in middle\n        if foot == "left":\n            start_x = target_position[0] - self.step_length  # Previous step position\n            start_y = -self.step_width / 2\n        else:  # right foot\n            start_x = target_position[0] - self.step_length\n            start_y = self.step_width / 2\n        \n        end_x = target_position[0] + self.step_length  # Next step position\n        end_y = -start_y if foot == "left" else self.step_width / 2  # Opposite foot position\n        \n        # Horizontal trajectory (smooth transition)\n        x_trajectory = self.fifth_order_polynomial(t_normalized, start_x, end_x)\n        \n        # Lateral trajectory \n        y_trajectory = self.fifth_order_polynomial(t_normalized, start_y, end_y)\n        \n        # Vertical trajectory (parabolic/elliptical lift)\n        # Reach max height in middle of swing\n        z_trajectory = np.zeros_like(time)\n        for i, t in enumerate(t_normalized):\n            # Parabolic curve: goes up then down\n            if t <= 0.5:\n                # Rising phase\n                z_trajectory[i] = self.step_height * (4 * t**2)  # Parabolic rise\n            else:\n                # Falling phase\n                z_trajectory[i] = self.step_height * (4 * (1-t)**2)  # Parabolic fall\n        \n        return x_trajectory, y_trajectory, z_trajectory\n    \n    def calculate_support_polygon(self, n_steps):\n        """\n        Calculate the support polygon for the walking pattern\n        """\n        polygons = []\n        for step in range(n_steps):\n            # Each support polygon is defined by the stance foot(s)\n            # This is a simplified representation\n            if step % 2 == 0:\n                # Left foot is stance foot\n                polygon = {\n                    \'step\': step,\n                    \'stance_foot\': \'left\',\n                    \'vertices\': [\n                        [-0.1, -0.07],  # Approximate foot boundary\n                        [0.1, -0.07],\n                        [0.1, 0.07],\n                        [-0.1, 0.07]\n                    ]\n                }\n            else:\n                # Right foot is stance foot\n                polygon = {\n                    \'step\': step,\n                    \'stance_foot\': \'right\', \n                    \'vertices\': [\n                        [-0.1, -0.07 + self.step_width],  # Offset for right foot\n                        [0.1, -0.07 + self.step_width],\n                        [0.1, 0.07 + self.step_width],\n                        [-0.1, 0.07 + self.step_width]\n                    ]\n                }\n            polygons.append(polygon)\n        \n        return polygons\n\n# Example usage\nwalker = WalkingPatternGenerator(com_height=0.85, step_length=0.3, step_duration=1.0)\nwalking_pattern = walker.generate_walking_pattern(n_steps=6, walking_direction="forward")\n\nprint(f"Generated walking pattern for {len(walking_pattern[\'step_times\'])} steps")\nprint(f"Trajectory duration: {walking_pattern[\'time\'][-1]:.2f} seconds")\nprint(f"Final CoM position: ({walking_pattern[\'com_trajectory\'][\'x\'][-1]:.2f}, {walking_pattern[\'com_trajectory\'][\'y\'][-1]:.2f})")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"linear-inverted-pendulum-model-lipm-for-walking",children:"Linear Inverted Pendulum Model (LIPM) for Walking"}),"\n",(0,i.jsx)(n.p,{children:"The Linear Inverted Pendulum Model is a foundational approach to understanding and generating stable walking patterns:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class LinearInvertedPendulumWalking:\n    def __init__(self, com_height=0.85, gravity=9.81):\n        self.com_height = com_height\n        self.gravity = gravity\n        self.omega = sqrt(gravity / com_height)\n    \n    def com_dynamics(self, t, state):\n        \"\"\"\n        Define the dynamics of the inverted pendulum\n        State = [x_com, x_vel, y_com, y_vel]\n        \"\"\"\n        x, x_dot, y, y_dot = state\n        x_ddot = self.omega**2 * x\n        y_ddot = self.omega**2 * y\n        \n        return [x_dot, x_ddot, y_dot, y_ddot]\n    \n    def solve_for_zmp(self, t, x_com, y_com):\n        \"\"\"\n        Calculate ZMP position for given CoM position\n        For LIPM: ZMP_x = CoM_x - (h/g) * CoM_x_dd\n        \"\"\"\n        # Since we're solving the differential equation forward,\n        # we can derive acceleration from position\n        # In a real system, we would solve this differently\n        pass\n    \n    def generate_lipm_trajectory(self, initial_state, final_state, duration):\n        \"\"\"\n        Generate CoM trajectory using LIPM with ZMP planning\n        \"\"\"\n        # For a simple example, use the LIPM solution\n        # x(t) = A * e^(\u03c9t) + B * e^(-\u03c9t)\n        x0, vx0, y0, vy0 = initial_state\n        \n        # Solve for A and B constants using initial conditions\n        # x(0) = A + B = x0\n        # x'(0) = \u03c9(A - B) = vx0 => A - B = vx0/\u03c9\n        A_x = (x0 + vx0/self.omega) / 2\n        B_x = (x0 - vx0/self.omega) / 2\n        \n        A_y = (y0 + vy0/self.omega) / 2\n        B_y = (y0 - vy0/self.omega) / 2\n        \n        # Generate time array\n        t_points = np.linspace(0, duration, int(duration * 100))  # 100Hz sampling\n        \n        # Calculate trajectories\n        com_x = A_x * np.exp(self.omega * t_points) + B_x * np.exp(-self.omega * t_points)\n        com_x_dot = self.omega * (A_x * np.exp(self.omega * t_points) - B_x * np.exp(-self.omega * t_points))\n        com_x_ddot = self.omega**2 * (A_x * np.exp(self.omega * t_points) + B_x * np.exp(-self.omega * t_points))\n        \n        com_y = A_y * np.exp(self.omega * t_points) + B_y * np.exp(-self.omega * t_points)\n        com_y_dot = self.omega * (A_y * np.exp(self.omega * t_points) - B_y * np.exp(-self.omega * t_points))\n        com_y_ddot = self.omega**2 * (A_y * np.exp(self.omega * t_points) + B_y * np.exp(-self.omega * t_points))\n        \n        # Calculate ZMP trajectory\n        zmp_x = com_x - (self.com_height / self.gravity) * com_x_ddot\n        zmp_y = com_y - (self.com_height / self.gravity) * com_y_ddot\n        \n        return {\n            'time': t_points,\n            'com_trajectory': {\n                'x': com_x,\n                'y': com_y,\n                'x_velocity': com_x_dot,\n                'y_velocity': com_y_dot,\n                'x_acceleration': com_x_ddot,\n                'y_acceleration': com_y_ddot\n            },\n            'zmp_trajectory': {\n                'x': zmp_x,\n                'y': zmp_y\n            }\n        }\n\n# Example LIPM usage\nlipm_walker = LinearInvertedPendulumWalking(com_height=0.85)\n\n# Start with CoM slightly off-center to see how it evolves\ninitial_state = [0.05, 0.1, 0.02, 0.05]  # [x, vx, y, vy]\nfinal_state = [0.3, 0.05, 0.0, 0.0]  # Target state after movement\n\nlipm_trajectory = lipm_walker.generate_lipm_trajectory(initial_state, final_state, 2.0)\n\nprint(f\"LIPM trajectory calculated for 2 seconds\")\nprint(f\"Initial CoM: ({initial_state[0]:.3f}, {initial_state[2]:.3f})\")\nprint(f\"Final CoM: ({lipm_trajectory['com_trajectory']['x'][-1]:.3f}, {lipm_trajectory['com_trajectory']['y'][-1]:.3f})\")\n"})}),"\n",(0,i.jsx)(n.h2,{id:"preview-control-for-walking",children:"Preview Control for Walking"}),"\n",(0,i.jsx)(n.p,{children:"Preview control uses planned future ZMP references to generate stable CoM trajectories:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from scipy.linalg import solve_discrete_are, inv\nfrom scipy import signal\n\nclass PreviewControllerWalking:\n    def __init__(self, com_height=0.85, dt=0.01, preview_window=2.0):\n        """\n        Initialize preview controller for walking\n        \n        Args:\n            com_height: Height of the center of mass\n            dt: Control time step\n            preview_window: How far ahead to look (seconds)\n        """\n        self.com_height = com_height\n        self.gravity = 9.81\n        self.dt = dt\n        self.omega = np.sqrt(self.gravity / com_height)\n        \n        # Number of steps to look ahead\n        self.preview_steps = int(preview_window / dt)\n        \n        # Discrete state-space system for LIPM\n        # State: x = [CoM_x, CoM_x_dot]\n        # Dynamics: x_{k+1} = A*x_k + B*zmp_k\n        self.A = np.array([\n            [1 + self.omega**2 * dt**2 / 2, dt],\n            [self.omega**2 * dt, 1.0]\n        ])\n        \n        self.B = np.array([self.omega**2 * dt**2 / 2, self.omega**2 * dt])\n        \n        # Output matrix to get ZMP from state\n        # For our system: zmp = x - (h/g)*acc = x - (h/g)*(\u03c9\xb2(x - zmp)) \n        # Which gives: zmp = x - (h/g)*(\u03c9\xb2(x - zmp)), solving: zmp = x - (h\u03c9\xb2/g)/(1+h\u03c9\xb2/g)*x\n        # Actually, let\'s use the LIPM relation directly\n        # zmp = x - (h/g)*acc where acc = omega^2 * (x - zmp)\n        # So zmp = x - (h/g)*omega^2*(x - zmp)\n        # zmp + (h/g)*omega^2*zmp = x - (h/g)*omega^2*x\n        # zmp = (x - (h/g)*omega^2*x) / (1 + (h/g)*omega^2)\n        # zmp = x * (1 - (h/g)*omega^2) / (1 + (h/g)*omega^2)\n        # Since h*omega^2/g = h*(g/h)/g = 1, this simplifies incorrectly\n        # Actually zmp = x - (h/g)*acc, and acc = d^2x/dt^2\n        # For numerical stability, we\'ll approximate output as x - offset\n        \n        # For simplicity, let\'s say output is just zmp (the control input)\n        # Since the dynamics are defined by ZMP, ZMP is the control input\n        \n        # Design LQR controller\n        Q = np.array([[100, 0], [0, 1]])  # State cost (penalize CoM deviation more)\n        R = 0.1  # Control cost (ZMP deviation)\n        \n        # Solve discrete-time algebraic Riccati equation\n        try:\n            P = solve_discrete_are(self.A.T, self.B.T, Q, R)\n            \n            # Calculate optimal gain\n            K = inv(R + self.B.T @ P @ self.B) @ (self.B.T @ P @ self.A)\n            self.feedback_gain = K\n            \n            # Precompute preview gains\n            self.preview_gains = self.calculate_preview_gains(Q, R, P)\n            \n        except np.linalg.LinAlgError:\n            # Fallback if Riccati equation doesn\'t converge\n            print("Warning: LQR design failed, using simple gain")\n            self.feedback_gain = np.array([1.0, 1.0])\n            self.preview_gains = np.zeros(self.preview_steps)\n    \n    def calculate_preview_gains(self, Q, R, P):\n        """\n        Calculate preview gains for future ZMP references\n        """\n        # This is a simplified calculation\n        # In practice, this involves solving for feedforward gains\n        gains = np.zeros(self.preview_steps)\n        \n        # For each preview step k, calculate the gain that maps future reference to current control\n        for k in range(self.preview_steps):\n            # The preview gain at step k depends on A^k, Q, R, and system matrices\n            A_pow = np.linalg.matrix_power(self.A, k)\n            \n            # Simplified preview gain calculation\n            # This is actually a complex calculation in full preview control theory\n            gains[k] = np.exp(-0.1 * k)  # Exponential decay weight for preview\n        \n        return gains\n    \n    def compute_control(self, current_state, zmp_reference_sequence):\n        """\n        Compute control input using preview control law\n        \n        Args:\n            current_state: Current state [x_com, x_com_dot]\n            zmp_reference_sequence: Sequence of future ZMP references\n            \n        Returns:\n            Control input (desired ZMP for next timestep)\n        """\n        # Feedback term\n        feedback_control = -self.feedback_gain @ current_state\n        \n        # Preview term (feedforward)\n        preview_control = 0.0\n        \n        # Apply preview gains to future references\n        n_refs = min(len(zmp_reference_sequence), self.preview_steps)\n        for k in range(n_refs):\n            weight = self.preview_gains[k]\n            if k < len(zmp_reference_sequence):\n                preview_control += weight * zmp_reference_sequence[k]\n        \n        total_control = feedback_control + preview_control\n        \n        return total_control[0] if hasattr(total_control, \'__len__\') else total_control\n    \n    def generate_walking_pattern_with_preview(self, step_length=0.3, step_duration=1.0, steps=6):\n        """\n        Generate walking pattern using preview control approach\n        """\n        total_time = steps * step_duration\n        n_points = int(total_time / self.dt)\n        time_points = np.linspace(0, total_time, n_points)\n        \n        # Initialize state and trajectory arrays\n        state = np.array([0.0, 0.0])  # [com_pos, com_vel]\n        com_positions = np.zeros(n_points)\n        com_velocities = np.zeros(n_points)\n        zmp_commands = np.zeros(n_points)\n        \n        # Define ZMP reference pattern (alternating support)\n        zmp_reference = np.zeros(n_points)\n        for i, t in enumerate(time_points):\n            step_no = int(t / step_duration)\n            if step_no % 2 == 0:  # Left foot support\n                zmp_reference[i] = -0.05  # Slightly left of center\n            else:  # Right foot support\n                zmp_reference[i] = 0.05   # Slightly right of center\n            \n            # Add forward progression\n            zmp_reference[i] += (step_no * step_length * 0.8)  # Gradual forward movement\n        \n        # Simulate walking using preview control\n        for i in range(n_points - 1):  # -1 to avoid index out of bounds\n            # Get preview window of future ZMP references\n            start_idx = i\n            end_idx = min(i + self.preview_steps, n_points)\n            zmp_preview = zmp_reference[start_idx:end_idx]\n            \n            # Compute control using preview controller\n            desired_zmp = self.compute_control(state, zmp_preview)\n            \n            # Update state using system dynamics\n            # x_next = A*x + B*u (where u is the desired ZMP)\n            state = self.A @ state + self.B * desired_zmp\n            \n            # Store results\n            com_positions[i+1] = state[0]\n            com_velocities[i+1] = state[1]\n            zmp_commands[i] = desired_zmp\n        \n        return {\n            \'time\': time_points,\n            \'com_position\': com_positions,\n            \'com_velocity\': com_velocities,\n            \'zmp_command\': zmp_commands,\n            \'zmp_reference\': zmp_reference,\n            \'step_times\': [i * step_duration for i in range(steps)]\n        }\n\n# Example usage of preview controller\npreview_walker = PreviewControllerWalking(com_height=0.85, dt=0.01, preview_window=1.0)\npreview_walking = preview_walker.generate_walking_pattern_with_preview(\n    step_length=0.3,\n    step_duration=1.0,\n    steps=6\n)\n\nprint(f"Preview control walking generated for {len(preview_walking[\'step_times\'])} steps")\nprint(f"Final CoM position: {preview_walking[\'com_position\'][-1]:.3f} m")\nprint(f"Final CoM velocity: {preview_walking[\'com_velocity\'][-1]:.3f} m/s")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"capture-point-based-walking",children:"Capture Point-Based Walking"}),"\n",(0,i.jsx)(n.p,{children:"The capture point is a critical concept for dynamic balance recovery:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class CapturePointWalking:\n    def __init__(self, com_height=0.85, gravity=9.81):\n        self.com_height = com_height\n        self.gravity = gravity\n        self.omega = sqrt(gravity / com_height)\n    \n    def calculate_capture_point(self, com_pos, com_vel):\n        """\n        Calculate capture point where robot should step to halt CoM motion\n        \n        Args:\n            com_pos: Current CoM position [x, y]\n            com_vel: Current CoM velocity [vx, vy]\n            \n        Returns:\n            Capture point position [x, y]\n        """\n        cp_x = com_pos[0] + com_vel[0] / self.omega\n        cp_y = com_pos[1] + com_vel[1] / self.omega\n        \n        return np.array([cp_x, cp_y])\n    \n    def generate_stable_step_locations(self, com_trajectory, step_timing):\n        """\n        Generate step locations based on capture point for stable walking\n        \n        Args:\n            com_trajectory: Dictionary with CoM positions and velocities\n            step_timing: Times at which to place feet\n            \n        Returns:\n            Array of step locations\n        """\n        step_locations = []\n        \n        for step_time in step_timing:\n            # Find closest CoM state to the step time\n            time_diffs = np.abs(com_trajectory[\'time\'] - step_time)\n            closest_idx = np.argmin(time_diffs)\n            \n            # Get CoM state at that time\n            com_pos = np.array([\n                com_trajectory[\'x\'][closest_idx], \n                com_trajectory[\'y\'][closest_idx]\n            ])\n            com_vel = np.array([\n                com_trajectory[\'vx\'][closest_idx] if \'vx\' in com_trajectory else 0,\n                com_trajectory[\'vy\'][closest_idx] if \'vy\' in com_trajectory else 0\n            ])\n            \n            # Calculate capture point\n            cp = self.calculate_capture_point(com_pos, com_vel)\n            \n            # Use capture point as target step location with safety margin\n            # Add slight offset for double support and step width\n            step_x = cp[0]\n            step_y = cp[1] + (self.step_width / 2) * ((len(step_locations) + 1) % 2 * 2 - 1)  # Alternate sides\n            \n            step_locations.append([step_x, step_y, 0.0])  # z=0 for foot on ground\n        \n        return np.array(step_locations)\n    \n    def implement_capture_point_control(self, current_com_pos, current_com_vel, support_feet_pos):\n        """\n        Implement capture point-based balance control\n        \n        Args:\n            current_com_pos: Current CoM position\n            current_com_vel: Current CoM velocity\n            support_feet_pos: Positions of support feet\n            \n        Returns:\n            Step location recommendation\n        """\n        # Calculate current capture point\n        current_cp = self.calculate_capture_point(current_com_pos, current_com_vel)\n        \n        # Determine if capture point is outside support polygon\n        support_polygon_valid = self.is_capture_point_stable(current_cp, support_feet_pos)\n        \n        if not support_polygon_valid:\n            # Need to take a step to move support polygon under capture point\n            step_location = self.plan_recovery_step(current_cp, support_feet_pos)\n            return {\n                \'action\': \'take_step\',\n                \'step_location\': step_location,\n                \'urgency\': \'high\'\n            }\n        else:\n            # Within stable region, continue normal walking\n            return {\n                \'action\': \'continue_normal\',\n                \'step_location\': None,\n                \'urgency\': \'low\'\n            }\n    \n    def is_capture_point_stable(self, capture_point, support_feet_pos):\n        """\n        Check if capture point is within support polygon\n        """\n        if len(support_feet_pos) == 0:\n            return False  # No support\n        \n        if len(support_feet_pos) == 1:\n            # Single support - check if CP is near the foot\n            foot_pos = support_feet_pos[0][:2]  # Get x,y only\n            distance_to_foot = np.linalg.norm(capture_point - foot_pos)\n            return distance_to_foot <= 0.1  # Within 10cm of foot (adjust as needed)\n        else:\n            # Double support - create convex hull and check if CP is inside\n            from scipy.spatial import ConvexHull\n            # Get x,y coordinates of support feet\n            support_xy = np.array([[foot[0], foot[1]] for foot in support_feet_pos]) \n            \n            try:\n                hull = ConvexHull(support_xy)\n                # Check if capture_point is inside the hull\n                return self.point_in_convex_hull(capture_point, hull, support_xy)\n            except:\n                # If hull computation fails, fall back to simpler check\n                return self.simple_polygon_check(capture_point, support_xy)\n    \n    def point_in_convex_hull(self, point, hull, points):\n        """\n        Check if a point is inside a 2D convex hull\n        """\n        # For each edge of the convex hull, check if point is on the correct side\n        for simplex in hull.simplices:\n            p1 = points[simplex[0]]\n            p2 = points[simplex[1]]\n            \n            # Calculate cross product to see which side of line point is on\n            cross_product = (p2[0] - p1[0]) * (point[1] - p1[1]) - (p2[1] - p1[1]) * (point[0] - p1[0])\n            \n            # For a counter-clockwise hull, all cross products should be positive\n            # for the point to be inside\n            if cross_product < 0:\n                return False\n        \n        return True\n    \n    def simple_polygon_check(self, point, vertices):\n        """\n        Simple check if point is in polygon using ray casting\n        """\n        x, y = point\n        n = len(vertices)\n        inside = False\n        \n        p1x, p1y = vertices[0]\n        for i in range(1, n + 1):\n            p2x, p2y = vertices[i % n]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xinters:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n        \n        return inside\n    \n    def plan_recovery_step(self, capture_point, current_support_feet):\n        """\n        Plan step location to move capture point to stability\n        """\n        # For recovery, step close to the capture point\n        # But also consider gait pattern and avoid placing foot too close to current stance foot\n        recovery_location = capture_point.copy()\n        \n        # Make sure it\'s not too close to any existing feet\n        for foot_pos in current_support_feet:\n            foot_xy = np.array([foot_pos[0], foot_pos[1]])\n            distance = np.linalg.norm(recovery_location - foot_xy)\n            \n            if distance < 0.3:  # Too close (less than 30cm)\n                # Adjust direction away from the close foot\n                direction = (recovery_location - foot_xy) / distance\n                recovery_location = foot_xy + direction * 0.3\n        \n        return [recovery_location[0], recovery_location[1], 0.0]\n\n# Example usage\ncp_walker = CapturePointWalking(com_height=0.85)\n\n# Simulate an unstable condition\ncom_position = np.array([0.1, 0.05])  # CoM slightly off position\ncom_velocity = np.array([0.3, 0.1])   # Moving with some velocity\nsupport_feet = np.array([[0.0, -0.1, 0.0], [0.0, 0.1, 0.0]])  # Feet in normal stance\n\ncontrol_action = cp_walker.implement_capture_point_control(com_position, com_velocity, support_feet)\n\nprint(f"Capture point control action: {control_action[\'action\']}")\nif control_action[\'step_location\'] is not None:\n    print(f"Recommended step location: {control_action[\'step_location\']}")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-walking-patterns",children:"Advanced Walking Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"dynamic-walking-with-momentum",children:"Dynamic Walking with Momentum"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class MomentumBasedWalking:\n    def __init__(self, robot_mass=50, com_height=0.85):\n        self.robot_mass = robot_mass\n        self.com_height = com_height\n        self.gravity = 9.81\n        self.omega = sqrt(self.gravity / com_height)\n    \n    def calculate_com_momentum(self, com_pos, com_vel):\n        \"\"\"\n        Calculate momentum of the center of mass\n        \"\"\"\n        linear_momentum = self.robot_mass * np.array(com_vel)\n        \n        return {\n            'linear_momentum': linear_momentum,\n            'momentum_magnitude': np.linalg.norm(linear_momentum)\n        }\n    \n    def generate_momentum_conserving_steps(self, desired_velocity, current_state):\n        \"\"\"\n        Generate stepping pattern that conserves momentum where possible\n        \"\"\"\n        # Desired momentum\n        desired_momentum = self.robot_mass * desired_velocity\n        \n        # Current momentum\n        current_momentum = self.robot_mass * current_state['com_velocity']\n        \n        # Momentum difference to be corrected through stepping\n        momentum_correction = desired_momentum - current_momentum\n        \n        # Plan steps to achieve desired momentum state\n        step_plan = self.plan_momentum_steps(momentum_correction, current_state)\n        \n        return step_plan\n    \n    def plan_momentum_steps(self, momentum_correction, current_state):\n        \"\"\"\n        Plan steps to correct momentum\n        \"\"\"\n        # Calculate required impulse (change in momentum)\n        required_impulse = momentum_correction\n        \n        # Determine how to distribute this impulse over upcoming steps\n        # This would involve more complex planning in a real implementation\n        \n        # For now, return a simple plan based on capture point and momentum\n        cp_calc = CapturePointWalking(com_height=self.com_height)\n        current_cp = cp_calc.calculate_capture_point(\n            current_state['com_position'][:2], \n            current_state['com_velocity'][:2]\n        )\n        \n        # Step location should account for both balance (capture point) and momentum\n        step_x = current_cp[0] + 0.3 * (required_impulse[0] / self.robot_mass)  # Factor for momentum correction\n        step_y = current_cp[1] + 0.3 * (required_impulse[1] / self.robot_mass)\n        \n        return {\n            'next_step_location': [step_x, step_y, 0.0],\n            'required_impulse': required_impulse,\n            'planned_velocity_change': required_impulse / self.robot_mass\n        }\n    \n    def implement_momentum_based_control(self, state_reference, current_state):\n        \"\"\"\n        Main control function using momentum principles\n        \"\"\"\n        # Calculate current momentum\n        current_momentum = self.calculate_com_momentum(\n            current_state['com_position'], \n            current_state['com_velocity']\n        )\n        \n        # Compare with desired momentum from reference\n        desired_momentum = self.robot_mass * state_reference['desired_velocity']\n        momentum_error = desired_momentum - current_momentum['linear_momentum']\n        \n        # Generate appropriate stepping and control commands\n        control_output = {\n            'momentum_error': momentum_error,\n            'correction_strategy': 'momentum_conserving',\n            'step_plan': self.plan_momentum_steps(momentum_error, current_state)\n        }\n        \n        return control_output\n\n# Example usage\nmom_walker = MomentumBasedWalking(robot_mass=60, com_height=0.85)\n\n# Current walking state\ncurrent_state = {\n    'com_position': np.array([0.5, 0.0, 0.85]),\n    'com_velocity': np.array([0.4, 0.05, 0.0])\n}\n\n# Desired state\nstate_reference = {\n    'desired_velocity': np.array([0.5, 0.0, 0.0])  # Want to accelerate forward\n}\n\nmomentum_control = mom_walker.implement_momentum_based_control(state_reference, current_state)\nprint(f\"Momentum-based control planned step to: {momentum_control['step_plan']['next_step_location']}\")\n"})}),"\n",(0,i.jsx)(n.h2,{id:"walking-pattern-visualization",children:"Walking Pattern Visualization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def visualize_walking_pattern(pattern_data):\n    \"\"\"\n    Visualize the generated walking pattern\n    \"\"\"\n    fig, axes = plt.subplots(2, 3, figsize=(18, 12))\n    \n    time = pattern_data['time']\n    \n    # Plot 1: CoM trajectory\n    axes[0, 0].plot(pattern_data['com_trajectory']['x'], pattern_data['com_trajectory']['y'], 'b-', linewidth=2, label='CoM Trajectory')\n    axes[0, 0].plot(pattern_data['left_foot_trajectory']['x'][::10], pattern_data['left_foot_trajectory']['y'][::10], 'ro', markersize=4, label='Left Foot Steps')\n    axes[0, 0].plot(pattern_data['right_foot_trajectory']['x'][::10], pattern_data['right_foot_trajectory']['y'][::10], 'go', markersize=4, label='Right Foot Steps')\n    axes[0, 0].set_xlabel('X Position (m)')\n    axes[0, 0].set_ylabel('Y Position (m)')\n    axes[0, 0].set_title('CoM and Foot Trajectories')\n    axes[0, 0].legend()\n    axes[0, 0].grid(True, alpha=0.3)\n    \n    # Plot 2: CoM height (should be mostly constant)\n    axes[0, 1].plot(time, pattern_data['com_trajectory']['z'], 'b-', linewidth=2)\n    axes[0, 1].set_xlabel('Time (s)')\n    axes[0, 1].set_ylabel('Height (m)')\n    axes[0, 1].set_title('CoM Height Over Time')\n    axes[0, 1].grid(True, alpha=0.3)\n    \n    # Plot 3: ZMP trajectory and support polygon\n    axes[0, 2].plot(pattern_data['zmp_trajectory']['x'], pattern_data['zmp_trajectory']['y'], 'r-', linewidth=2, label='ZMP Trajectory')\n    \n    # Plot support polygon boundaries for each step\n    for poly in pattern_data['support_polygon']:\n        vertices = np.array(poly['vertices'])\n        vertices_closed = np.vstack([vertices, vertices[0]])  # Close the polygon\n        axes[0, 2].plot(vertices_closed[:, 0], vertices_closed[:, 1], '--', alpha=0.7, label=f'Step {poly[\"step\"]} Support' if poly['step'] <= 2 else \"\")\n    \n    axes[0, 2].set_xlabel('X Position (m)')\n    axes[0, 2].set_ylabel('Y Position (m)')\n    axes[0, 2].set_title('ZMP Trajectory vs Support Polygon')\n    axes[0, 2].legend()\n    axes[0, 2].grid(True, alpha=0.3)\n    \n    # Plot 4: Foot heights over time\n    axes[1, 0].plot(time, pattern_data['left_foot_trajectory']['z'], label='Left Foot Height', linewidth=2)\n    axes[1, 0].plot(time, pattern_data['right_foot_trajectory']['z'], label='Right Foot Height', linewidth=2)\n    axes[1, 0].set_xlabel('Time (s)')\n    axes[1, 0].set_ylabel('Height (m)')\n    axes[1, 0].set_title('Foot Height Profiles Over Time')\n    axes[1, 0].legend()\n    axes[1, 0].grid(True, alpha=0.3)\n    \n    # Plot 5: CoM velocity profiles\n    com_vel_x = np.gradient(pattern_data['com_trajectory']['x'], time[1]-time[0])\n    com_vel_y = np.gradient(pattern_data['com_trajectory']['y'], time[1]-time[0])\n    axes[1, 1].plot(time, com_vel_x, label='CoM Velocity X', linewidth=2)\n    axes[1, 1].plot(time, com_vel_y, label='CoM Velocity Y', linewidth=2)\n    axes[1, 1].set_xlabel('Time (s)')\n    axes[1, 1].set_ylabel('Velocity (m/s)')\n    axes[1, 1].set_title('CoM Velocity Profiles')\n    axes[1, 1].legend()\n    axes[1, 1].grid(True, alpha=0.3)\n    \n    # Plot 6: Step timing and gait phases\n    axes[1, 2].eventplot([pattern_data['step_times']], colors=['blue'], linelengths=0.5, label='Step Times')\n    axes[1, 2].set_xlabel('Time (s)')\n    axes[1, 2].set_ylabel('Events')\n    axes[1, 2].set_title('Step Timing Events')\n    axes[1, 2].legend()\n    axes[1, 2].grid(True, alpha=0.3)\n    \n    plt.tight_layout()\n    plt.show()\n\n# Visualize the walking pattern\nvisualize_walking_pattern(walking_pattern)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"walking-stability-metrics",children:"Walking Stability Metrics"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class WalkingStabilityAnalyzer:\n    def __init__(self, robot_params):\n        self.com_height = robot_params.get('com_height', 0.85)\n        self.foot_size = robot_params.get('foot_size', [0.25, 0.1])  # [length, width]\n        self.gravity = 9.81\n        \n    def calculate_stability_margins(self, pattern_data):\n        \"\"\"\n        Calculate stability margins for the walking pattern\n        \"\"\"\n        stability_analysis = {\n            'time_to_unstable': [],\n            'minimum_zmp_margin': [],\n            'capture_point_deviation': [],\n            'angular_momentum': []\n        }\n        \n        com_x = pattern_data['com_trajectory']['x']\n        com_y = pattern_data['com_trajectory']['y']\n        zmp_x = pattern_data['zmp_trajectory']['x']\n        zmp_y = pattern_data['zmp_trajectory']['y']\n        \n        # Calculate velocities and accelerations\n        dt = pattern_data['time'][1] - pattern_data['time'][0]\n        com_vel_x = np.gradient(com_x, dt)\n        com_vel_y = np.gradient(com_y, dt)\n        com_acc_x = np.gradient(com_vel_x, dt)\n        com_acc_y = np.gradient(com_vel_y, dt)\n        \n        # Calculate instantaneous stability metrics\n        for i in range(len(zmp_x)):\n            # Calculate instantaneous capture point\n            instant_cp_x = com_x[i] + com_vel_x[i] / sqrt(self.gravity / self.com_height)\n            instant_cp_y = com_y[i] + com_vel_y[i] / sqrt(self.gravity / self.com_height)\n            \n            # Calculate distance from ZMP to support polygon edge\n            # For simplicity, assume rectangular support polygon based on foot placement\n            current_support_polygon = self.get_current_support_polygon(\n                pattern_data, \n                pattern_data['time'][i]\n            )\n            \n            zmp_pos = np.array([zmp_x[i], zmp_y[i]])\n            cp_pos = np.array([instant_cp_x, instant_cp_y])\n            \n            # Calculate distance to polygon boundary\n            zmp_margin = self.distance_to_polygon_boundary(zmp_pos, current_support_polygon)\n            cp_deviation = self.distance_to_polygon_boundary(cp_pos, current_support_polygon)\n            \n            stability_analysis['minimum_zmp_margin'].append(zmp_margin)\n            stability_analysis['capture_point_deviation'].append(cp_deviation)\n            \n            # Angular momentum (simplified)\n            angular_mom = com_vel_x[i] * com_acc_y[i] - com_vel_y[i] * com_acc_x[i]\n            stability_analysis['angular_momentum'].append(angular_mom)\n        \n        return stability_analysis\n    \n    def get_current_support_polygon(self, pattern_data, current_time):\n        \"\"\"\n        Determine the current support polygon based on foot positions\n        \"\"\"\n        # Find which feet are currently in contact with ground\n        time_idx = min(int(current_time / 0.01), len(pattern_data['time']) - 1)\n        \n        left_z = pattern_data['left_foot_trajectory']['z'][time_idx]\n        right_z = pattern_data['right_foot_trajectory']['z'][time_idx]\n        \n        supports = []\n        if left_z < 0.01:  # Left foot is down (considering small threshold for contact)\n            supports.append([pattern_data['left_foot_trajectory']['x'][time_idx], \n                           pattern_data['left_foot_trajectory']['y'][time_idx]])\n        \n        if right_z < 0.01:  # Right foot is down\n            supports.append([pattern_data['right_foot_trajectory']['x'][time_idx], \n                           pattern_data['right_foot_trajectory']['y'][time_idx]])\n        \n        # Create support polygon from supporting feet\n        if len(supports) == 0:\n            return []  # No support\n        elif len(supports) == 1:\n            # Single support - create a small polygon around the foot\n            foot_pos = supports[0]\n            return [\n                [foot_pos[0] - self.foot_size[0]/2, foot_pos[1] - self.foot_size[1]/2],\n                [foot_pos[0] + self.foot_size[0]/2, foot_pos[1] - self.foot_size[1]/2],\n                [foot_pos[0] + self.foot_size[0]/2, foot_pos[1] + self.foot_size[1]/2],\n                [foot_pos[0] - self.foot_size[0]/2, foot_pos[1] + self.foot_size[1]/2]\n            ]\n        else:\n            # Double support - create polygon spanning both feet\n            # Simplified convex hull\n            return [\n                [supports[0][0] - self.foot_size[0]/4, supports[0][1] - self.foot_size[1]/2],\n                [supports[1][0] - self.foot_size[0]/4, supports[1][1] - self.foot_size[1]/2],\n                [supports[1][0] + self.foot_size[0]/4, supports[1][1] + self.foot_size[1]/2],\n                [supports[0][0] + self.foot_size[0]/4, supports[0][1] + self.foot_size[1]/2]\n            ]\n    \n    def distance_to_polygon_boundary(self, point, polygon):\n        \"\"\"\n        Calculate minimum distance from a point to the boundary of a polygon\n        \"\"\"\n        if len(polygon) < 2:\n            return float('inf')\n        \n        min_dist = float('inf')\n        point = np.array(point)\n        \n        # Calculate distance to each edge of the polygon\n        for i in range(len(polygon)):\n            p1 = np.array(polygon[i])\n            p2 = np.array(polygon[(i + 1) % len(polygon)])\n            \n            # Calculate distance from point to line segment p1-p2\n            dist = self.point_to_line_segment_distance(point, p1, p2)\n            min_dist = min(min_dist, dist)\n        \n        return min_dist\n    \n    def point_to_line_segment_distance(self, point, line_start, line_end):\n        \"\"\"\n        Calculate distance from a point to a line segment\n        \"\"\"\n        # Vector from line_start to line_end\n        line_vec = line_end - line_start\n        point_vec = point - line_start\n        \n        # Length squared of the line segment\n        line_len_sq = np.dot(line_vec, line_vec)\n        \n        if line_len_sq == 0:\n            # Line segment is actually a point\n            return np.linalg.norm(point - line_start)\n        \n        # Project point_vec onto line_vec to find closest point on the line\n        t = max(0, min(1, np.dot(point_vec, line_vec) / line_len_sq))\n        \n        # Calculate the closest point on the line segment\n        projection = line_start + t * line_vec\n        \n        # Return the distance to the closest point\n        return np.linalg.norm(point - projection)\n    \n    def evaluate_walking_stability(self, pattern_data):\n        \"\"\"\n        Comprehensive stability evaluation of the walking pattern\n        \"\"\"\n        stability_metrics = {\n            'average_zmp_margin': 0,\n            'minimum_zmp_margin': float('inf'),\n            'maximum_zmp_margin': float('-inf'),\n            'zmp_margin_std': 0,\n            'stability_score': 0,  # 0-1 scale, 1 is perfectly stable\n            'instability_events': 0,\n            'time_in_stable_region': 0\n        }\n        \n        # Calculate stability margins\n        stability_analysis = self.calculate_stability_margins(pattern_data)\n        \n        margins = stability_analysis['minimum_zmp_margin']\n        \n        if len(margins) > 0:\n            stability_metrics['average_zmp_margin'] = np.mean(margins)\n            stability_metrics['minimum_zmp_margin'] = np.min(margins)\n            stability_metrics['maximum_zmp_margin'] = np.max(margins)\n            stability_metrics['zmp_margin_std'] = np.std(margins)\n            \n            # Calculate stability score (0-1 scale)\n            # Penalize low margins and high variance\n            avg_margin = stability_metrics['average_zmp_margin']\n            std_margin = stability_metrics['zmp_margin_std']\n            \n            # Score based on average margin and consistency\n            margin_score = np.tanh(avg_margin * 10)  # Higher margins are better, capped\n            consistency_score = 1.0 / (1.0 + std_margin)  # Lower variance is better\n            \n            stability_metrics['stability_score'] = 0.7 * margin_score + 0.3 * consistency_score\n            \n            # Count instability events (negative margins)\n            stability_metrics['instability_events'] = np.sum(np.array(margins) < 0)\n            stability_metrics['time_in_stable_region'] = np.sum(np.array(margins) > 0.05)  # Stable if > 5cm margin\n            stability_metrics['time_in_stable_region'] /= len(margins)  # As fraction of total time\n        \n        return stability_metrics\n\n# Example analysis\nanalyzer = WalkingStabilityAnalyzer({'com_height': 0.85})\nstability_eval = analyzer.evaluate_walking_stability(walking_pattern)\n\nprint(\"Walking Pattern Stability Analysis:\")\nprint(f\"  Average ZMP Margin: {stability_eval['average_zmp_margin']:.3f} m\")\nprint(f\"  Minimum ZMP Margin: {stability_eval['minimum_zmp_margin']:.3f} m\")\nprint(f\"  Maximum ZMP Margin: {stability_eval['maximum_zmp_margin']:.3f} m\")\nprint(f\"  Stability Score: {stability_eval['stability_score']:.3f} (1 = perfectly stable)\")\nprint(f\"  Instability Events: {stability_eval['instability_events']}\")\nprint(f\"  Time in Stable Region: {stability_eval['time_in_stable_region']*100:.1f}% of total time\")\n"})}),"\n",(0,i.jsx)(n.h2,{id:"hands-on-exercise",children:"Hands-on Exercise"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Implement a walking controller that adjusts step timing and location based on external disturbances."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Design a gait adaptation algorithm that modifies walking parameters when walking on uneven terrain."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Using the educational AI agents, explore how different walking parameters (step length, duration, height) affect the stability and energy efficiency of humanoid locomotion."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The next section will explore how these walking algorithms are implemented in real hardware and the challenges of adapting the algorithms to physical constraints."})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(_,{...e})}):_(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var o=t(6540);const i={},a=o.createContext(i);function r(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);