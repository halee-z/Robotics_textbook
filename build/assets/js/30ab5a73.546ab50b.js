"use strict";(globalThis.webpackChunkeducational_ai_humanoid_robotics=globalThis.webpackChunkeducational_ai_humanoid_robotics||[]).push([[527],{3302:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"humanoid-robotics/introduction","title":"Humanoid Robotics: Kinematics, Dynamics, and Control","description":"Overview","source":"@site/docs/humanoid-robotics/introduction.md","sourceDirName":"humanoid-robotics","slug":"/humanoid-robotics/introduction","permalink":"/educational-ai-humanoid-robotics/docs/humanoid-robotics/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/educational-ai-humanoid-robotics/educational-ai-humanoid-robotics.github.io/tree/main/packages/create-docusaurus/templates/shared/docs/humanoid-robotics/introduction.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Unity Robotics Simulation for Humanoid Applications","permalink":"/educational-ai-humanoid-robotics/docs/simulation/unity-robotics"},"next":{"title":"Humanoid Robot Kinematics: Structure and Motion","permalink":"/educational-ai-humanoid-robotics/docs/humanoid-robotics/kinematics"}}');var t=i(4848),r=i(8453);const a={sidebar_position:1},l="Humanoid Robotics: Kinematics, Dynamics, and Control",s={},c=[{value:"Overview",id:"overview",level:2},{value:"What Makes Humanoid Robotics Challenging?",id:"what-makes-humanoid-robotics-challenging",level:2},{value:"High Degrees of Freedom (DOF)",id:"high-degrees-of-freedom-dof",level:3},{value:"Dynamic Balance",id:"dynamic-balance",level:3},{value:"Real-time Constraints",id:"real-time-constraints",level:3},{value:"Complex Dynamics",id:"complex-dynamics",level:3},{value:"Kinematics of Humanoid Robots",id:"kinematics-of-humanoid-robots",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Kinematic Chains",id:"kinematic-chains",level:3},{value:"Dynamics and Control",id:"dynamics-and-control",level:2},{value:"Equation of Motion",id:"equation-of-motion",level:3},{value:"Control Approaches",id:"control-approaches",level:3},{value:"Operational Space Control",id:"operational-space-control",level:4},{value:"Whole-Body Control",id:"whole-body-control",level:4},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:4},{value:"Locomotion Strategies",id:"locomotion-strategies",level:2},{value:"Static vs. Dynamic Walking",id:"static-vs-dynamic-walking",level:3},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:3},{value:"Balance Control",id:"balance-control",level:2},{value:"Linear Inverted Pendulum Model (LIPM)",id:"linear-inverted-pendulum-model-lipm",level:3},{value:"Balance Strategies",id:"balance-strategies",level:3},{value:"Humanoid Robot Design Considerations",id:"humanoid-robot-design-considerations",level:2},{value:"Actuation",id:"actuation",level:3},{value:"Sensing",id:"sensing",level:3},{value:"Mechanical Design",id:"mechanical-design",level:3},{value:"Control Architectures",id:"control-architectures",level:2},{value:"Hierarchical Control",id:"hierarchical-control",level:3},{value:"Stability Considerations",id:"stability-considerations",level:3},{value:"Applications in Education",id:"applications-in-education",level:2},{value:"Engage Students",id:"engage-students",level:3},{value:"Illustrate Complex Concepts",id:"illustrate-complex-concepts",level:3},{value:"Foster Innovation",id:"foster-innovation",level:3},{value:"Exercises and Projects",id:"exercises-and-projects",level:2},{value:"Exercise 1: Inverse Kinematics for Arm Reaching",id:"exercise-1-inverse-kinematics-for-arm-reaching",level:3},{value:"Exercise 2: Balance Controller",id:"exercise-2-balance-controller",level:3},{value:"Project: Walking Controller",id:"project-walking-controller",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"humanoid-robotics-kinematics-dynamics-and-control",children:"Humanoid Robotics: Kinematics, Dynamics, and Control"})}),"\n",(0,t.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robotics represents one of the most challenging areas in robotics, requiring sophisticated approaches to kinematics, dynamics, and control. A humanoid robot must navigate complex environments, interact with objects designed for humans, and potentially work alongside humans. This section covers the fundamental principles of humanoid robot design and control."}),"\n",(0,t.jsx)(e.h2,{id:"what-makes-humanoid-robotics-challenging",children:"What Makes Humanoid Robotics Challenging?"}),"\n",(0,t.jsx)(e.h3,{id:"high-degrees-of-freedom-dof",children:"High Degrees of Freedom (DOF)"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots typically have 20-40+ joints, making control and planning computationally intensive compared to simpler robots."}),"\n",(0,t.jsx)(e.h3,{id:"dynamic-balance",children:"Dynamic Balance"}),"\n",(0,t.jsx)(e.p,{children:"Unlike wheeled robots or manipulators, humanoid robots must maintain balance while moving, making locomotion a complex control problem."}),"\n",(0,t.jsx)(e.h3,{id:"real-time-constraints",children:"Real-time Constraints"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots must react quickly to maintain balance and respond to environmental changes, requiring real-time control systems."}),"\n",(0,t.jsx)(e.h3,{id:"complex-dynamics",children:"Complex Dynamics"}),"\n",(0,t.jsx)(e.p,{children:"The coupled dynamics of multiple linked bodies make modeling and control significantly more complex than simpler robotic systems."}),"\n",(0,t.jsx)(e.h2,{id:"kinematics-of-humanoid-robots",children:"Kinematics of Humanoid Robots"}),"\n",(0,t.jsx)(e.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,t.jsx)(e.p,{children:"Forward kinematics maps joint angles to end-effector positions in space. For humanoid robots, this is essential for:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Arm reaching and manipulation"}),"\n",(0,t.jsx)(e.li,{children:"Foot placement during walking"}),"\n",(0,t.jsx)(e.li,{children:"Head orientation for vision"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,t.jsx)(e.p,{children:"Inverse kinematics solves for joint angles that achieve desired end-effector positions. In humanoid robotics:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Solving for natural poses"}),"\n",(0,t.jsx)(e.li,{children:"Avoiding joint limits and obstacles"}),"\n",(0,t.jsx)(e.li,{children:"Maintaining balance constraints"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"kinematic-chains",children:"Kinematic Chains"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots typically have multiple kinematic chains:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Left and right legs"}),"\n",(0,t.jsx)(e.li,{children:"Left and right arms"}),"\n",(0,t.jsx)(e.li,{children:"Head and neck"}),"\n",(0,t.jsx)(e.li,{children:"Spine (if applicable)"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"dynamics-and-control",children:"Dynamics and Control"}),"\n",(0,t.jsx)(e.h3,{id:"equation-of-motion",children:"Equation of Motion"}),"\n",(0,t.jsx)(e.p,{children:"The dynamics of a humanoid robot are described by the equation:"}),"\n",(0,t.jsx)(e.p,{children:"M(q)q\u0308 + C(q, q\u0307)q\u0307 + G(q) = \u03c4 + J\u1d40(q)F"}),"\n",(0,t.jsx)(e.p,{children:"Where:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"M(q) is the mass matrix"}),"\n",(0,t.jsx)(e.li,{children:"C(q, q\u0307) contains Coriolis and centrifugal terms"}),"\n",(0,t.jsx)(e.li,{children:"G(q) represents gravitational forces"}),"\n",(0,t.jsx)(e.li,{children:"\u03c4 represents joint torques"}),"\n",(0,t.jsx)(e.li,{children:"J\u1d40(q)F represents external forces"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"control-approaches",children:"Control Approaches"}),"\n",(0,t.jsx)(e.h4,{id:"operational-space-control",children:"Operational Space Control"}),"\n",(0,t.jsx)(e.p,{children:"Controls end-effectors in Cartesian space while maintaining joint-level constraints:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# Simplified operational space control for foot placement\ndef operational_space_control(robot_state, desired_position, desired_orientation):\n    # Calculate Jacobian\n    J = robot.compute_jacobian('foot_link')\n    \n    # Calculate position error\n    pos_error = desired_position - robot_state.current_position\n    \n    # Calculate orientation error\n    orientation_error = calculate_orientation_error(\n        desired_orientation, \n        robot_state.current_orientation\n    )\n    \n    # Map task-space error to joint-space\n    error = np.concatenate([pos_error, orientation_error])\n    joint_velocities = np.linalg.pinv(J) @ error\n    \n    return joint_velocities\n"})}),"\n",(0,t.jsx)(e.h4,{id:"whole-body-control",children:"Whole-Body Control"}),"\n",(0,t.jsx)(e.p,{children:"Considers the entire robot as a single system, optimizing for multiple objectives simultaneously:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Balance maintenance"}),"\n",(0,t.jsx)(e.li,{children:"Task execution"}),"\n",(0,t.jsx)(e.li,{children:"Joint limit avoidance"}),"\n",(0,t.jsx)(e.li,{children:"Energy efficiency"}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,t.jsx)(e.p,{children:"Uses predictive models to optimize control over a finite horizon, particularly useful for:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Walking pattern generation"}),"\n",(0,t.jsx)(e.li,{children:"Balance recovery"}),"\n",(0,t.jsx)(e.li,{children:"Contact planning"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"locomotion-strategies",children:"Locomotion Strategies"}),"\n",(0,t.jsx)(e.h3,{id:"static-vs-dynamic-walking",children:"Static vs. Dynamic Walking"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Static Walking"}),": Center of Mass (CoM) remains over support polygon at all times"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Walking"}),": CoM may leave support polygon, requiring dynamic balance"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,t.jsx)(e.p,{children:"The ZMP is a key concept in humanoid locomotion where the sum of moments due to external forces is zero. Maintaining ZMP within the support polygon ensures dynamic stability."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"def calculate_zmp(robot_state):\n    # Simplified ZMP calculation\n    CoM = robot_state.center_of_mass\n    CoM_height = CoM[2] - robot_state.support_plane_height\n    gravity = 9.81\n    CoM_acceleration = robot_state.center_of_mass_acceleration\n    \n    # ZMP_x = CoM_x - (CoM_height/g) * CoM_acceleration_x\n    zmp_x = CoM[0] - (CoM_height / gravity) * CoM_acceleration[0]\n    zmp_y = CoM[1] - (CoM_height / gravity) * CoM_acceleration[1]\n    \n    return np.array([zmp_x, zmp_y, robot_state.support_plane_height])\n"})}),"\n",(0,t.jsx)(e.h3,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,t.jsx)(e.p,{children:"Common approaches include:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Preview Control"}),": Uses future ZMP references to generate stable walking patterns"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Divergent Component of Motion (DCM)"}),": Plans for global stability using capture point dynamics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Footstep Planning"}),": Determines optimal foot placement for stability"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"balance-control",children:"Balance Control"}),"\n",(0,t.jsx)(e.h3,{id:"linear-inverted-pendulum-model-lipm",children:"Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,t.jsx)(e.p,{children:"A simplified model for humanoid balance control:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"class LIPMController:\n    def __init__(self, com_height, gravity=9.81):\n        self.com_height = com_height\n        self.omega = np.sqrt(gravity / com_height)\n        \n    def calculate_capture_point(self, com_pos, com_vel):\n        # Capture point calculation for balance recovery\n        capture_point = com_pos + com_vel / self.omega\n        return capture_point\n"})}),"\n",(0,t.jsx)(e.h3,{id:"balance-strategies",children:"Balance Strategies"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Ankle Strategy"}),": Small perturbations corrected by ankle torques"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Hip Strategy"}),": Larger perturbations corrected by hip movements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stepping Strategy"}),": Regain balance by taking a step"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Hip-Hop Strategy"}),": Use arm movements for balance"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"humanoid-robot-design-considerations",children:"Humanoid Robot Design Considerations"}),"\n",(0,t.jsx)(e.h3,{id:"actuation",children:"Actuation"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots require actuators that can:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Provide sufficient torque for dynamic movement"}),"\n",(0,t.jsx)(e.li,{children:"Respond quickly to control commands"}),"\n",(0,t.jsx)(e.li,{children:"Handle both actuation and compliance control"}),"\n",(0,t.jsx)(e.li,{children:"Operate efficiently for extended periods"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"sensing",children:"Sensing"}),"\n",(0,t.jsx)(e.p,{children:"Essential sensors for humanoid robots:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"IMU"}),": Measures orientation, angular velocity, and linear acceleration"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Force/Torque Sensors"}),": At feet and hands for contact information"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Joint Position Sensors"}),": For kinematic feedback"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Vision/LIDAR"}),": For environment perception"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"mechanical-design",children:"Mechanical Design"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Backdrivable Actuators"}),": Allow for compliant behavior"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Lightweight Structures"}),": To reduce inertial forces"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Robust Joints"}),": To handle dynamic loads"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Modular Design"}),": For maintainability and upgrades"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"control-architectures",children:"Control Architectures"}),"\n",(0,t.jsx)(e.h3,{id:"hierarchical-control",children:"Hierarchical Control"}),"\n",(0,t.jsx)(e.p,{children:"A common approach in humanoid robotics is hierarchical control with different time scales:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"High Level (1-10 Hz)\n\u251c\u2500\u2500 Walking pattern generation\n\u251c\u2500\u2500 Footstep planning\n\u2514\u2500\u2500 Task planning\n\nMid Level (50-200 Hz)\n\u251c\u2500\u2500 Balance control\n\u251c\u2500\u2500 Trajectory generation\n\u2514\u2500\u2500 Contact planning\n\nLow Level (1-10 kHz)\n\u251c\u2500\u2500 Joint control\n\u251c\u2500\u2500 Sensor feedback\n\u2514\u2500\u2500 Safety monitoring\n"})}),"\n",(0,t.jsx)(e.h3,{id:"stability-considerations",children:"Stability Considerations"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real-time Safety"}),": Emergency stops and safe-fall mechanisms"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Disturbance Rejection"}),": Handling unexpected external forces"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Robust Control"}),": Maintaining performance under model uncertainties"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"applications-in-education",children:"Applications in Education"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots are particularly valuable in educational settings because they:"}),"\n",(0,t.jsx)(e.h3,{id:"engage-students",children:"Engage Students"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Relatable form factor"}),"\n",(0,t.jsx)(e.li,{children:"Interactive capabilities"}),"\n",(0,t.jsx)(e.li,{children:"Demonstrates multiple engineering disciplines"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"illustrate-complex-concepts",children:"Illustrate Complex Concepts"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Control theory in practice"}),"\n",(0,t.jsx)(e.li,{children:"Multi-disciplinary integration"}),"\n",(0,t.jsx)(e.li,{children:"Real-world applications of algorithms"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"foster-innovation",children:"Foster Innovation"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Open research platforms"}),"\n",(0,t.jsx)(e.li,{children:"Hackable hardware and software"}),"\n",(0,t.jsx)(e.li,{children:"Experimentation opportunities"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"exercises-and-projects",children:"Exercises and Projects"}),"\n",(0,t.jsx)(e.h3,{id:"exercise-1-inverse-kinematics-for-arm-reaching",children:"Exercise 1: Inverse Kinematics for Arm Reaching"}),"\n",(0,t.jsx)(e.p,{children:"Implement inverse kinematics for a humanoid robot arm to reach specific target positions in 3D space."}),"\n",(0,t.jsx)(e.h3,{id:"exercise-2-balance-controller",children:"Exercise 2: Balance Controller"}),"\n",(0,t.jsx)(e.p,{children:"Create a simple balance controller that maintains a robot's center of mass over its support polygon."}),"\n",(0,t.jsx)(e.h3,{id:"project-walking-controller",children:"Project: Walking Controller"}),"\n",(0,t.jsx)(e.p,{children:"Design and implement a complete walking controller for a simulated humanoid robot, integrating:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Trajectory generation"}),"\n",(0,t.jsx)(e.li,{children:"Balance control"}),"\n",(0,t.jsx)(e.li,{children:"Footstep planning"}),"\n",(0,t.jsx)(e.li,{children:"ZMP regulation"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"The next section will explore human-robot interaction principles specific to humanoid robots."})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>l});var o=i(6540);const t={},r=o.createContext(t);function a(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);