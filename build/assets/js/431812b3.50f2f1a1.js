"use strict";(globalThis.webpackChunkeducational_ai_humanoid_robotics=globalThis.webpackChunkeducational_ai_humanoid_robotics||[]).push([[367],{4013:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>t,toc:()=>_});const t=JSON.parse('{"id":"humanoid-robotics/kinematics","title":"Humanoid Robot Kinematics: Structure and Motion","description":"Overview","source":"@site/docs/humanoid-robotics/kinematics.md","sourceDirName":"humanoid-robotics","slug":"/humanoid-robotics/kinematics","permalink":"/educational-ai-humanoid-robotics/docs/humanoid-robotics/kinematics","draft":false,"unlisted":false,"editUrl":"https://github.com/educational-ai-humanoid-robotics/educational-ai-humanoid-robotics.github.io/tree/main/packages/create-docusaurus/templates/shared/docs/humanoid-robotics/kinematics.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid Robotics: Kinematics, Dynamics, and Control","permalink":"/educational-ai-humanoid-robotics/docs/humanoid-robotics/introduction"},"next":{"title":"Control Systems for Humanoid Robots","permalink":"/educational-ai-humanoid-robotics/docs/humanoid-robotics/control-systems"}}');var o=i(4848),a=i(8453);const l={sidebar_position:2},r="Humanoid Robot Kinematics: Structure and Motion",s={},_=[{value:"Overview",id:"overview",level:2},{value:"Kinematic Structure of Humanoid Robots",id:"kinematic-structure-of-humanoid-robots",level:2},{value:"Degrees of Freedom",id:"degrees-of-freedom",level:3},{value:"Kinematic Chains",id:"kinematic-chains",level:3},{value:"Forward Kinematics",id:"forward-kinematics",level:2},{value:"Mathematical Foundation",id:"mathematical-foundation",level:3},{value:"Implementation Example",id:"implementation-example",level:3},{value:"Whole-Body Forward Kinematics",id:"whole-body-forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:2},{value:"Analytical IK for Arms",id:"analytical-ik-for-arms",level:3},{value:"Iterative IK for Complex Chains",id:"iterative-ik-for-complex-chains",level:3},{value:"Center of Mass Calculation",id:"center-of-mass-calculation",level:2},{value:"Practical Considerations",id:"practical-considerations",level:2},{value:"Joint Limits and Constraints",id:"joint-limits-and-constraints",level:3},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"humanoid-robot-kinematics-structure-and-motion",children:"Humanoid Robot Kinematics: Structure and Motion"})}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robot kinematics is the study of motion in humanoid robots without considering the forces that cause the motion. Understanding kinematics is fundamental to controlling humanoid robots, enabling them to perform complex movements while maintaining balance and achieving task objectives. This section covers the mathematical foundations, implementation approaches, and practical considerations for humanoid robot kinematics."}),"\n",(0,o.jsx)(e.h2,{id:"kinematic-structure-of-humanoid-robots",children:"Kinematic Structure of Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"degrees-of-freedom",children:"Degrees of Freedom"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots typically have many degrees of freedom (DOF) to achieve human-like movement:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Head/Neck"}),": 3-6 DOF (yaw, pitch, roll; optional translation)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Trunk"}),": 6-12 DOF (waist rotation, lateral bending, pitch; optional translation)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Each Arm"}),": 7-9 DOF (shoulder: 3 DOF, elbow: 1 DOF, wrist: 2-3 DOF, optional hand DOF)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Each Leg"}),": 6-7 DOF (hip: 3 DOF, knee: 1 DOF, ankle: 2-3 DOF)"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"This results in humanoid robots having between 26-40+ total DOF, making their control significantly more complex than simpler robots."}),"\n",(0,o.jsx)(e.h3,{id:"kinematic-chains",children:"Kinematic Chains"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots have multiple kinematic chains that work together:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Base (Trunk/Body)\n\u251c\u2500\u2500 Left Leg Chain\n\u2502   \u251c\u2500\u2500 Hip (3 DOF: yaw, pitch, roll)\n\u2502   \u251c\u2500\u2500 Knee (1 DOF: pitch)\n\u2502   \u2514\u2500\u2500 Ankle (2-3 DOF: pitch, roll, optional translation)\n\u251c\u2500\u2500 Right Leg Chain\n\u2502   \u251c\u2500\u2500 Hip (3 DOF)\n\u2502   \u251c\u2500\u2500 Knee (1 DOF)\n\u2502   \u2514\u2500\u2500 Ankle (2-3 DOF)\n\u251c\u2500\u2500 Left Arm Chain\n\u2502   \u251c\u2500\u2500 Shoulder (3 DOF)\n\u2502   \u251c\u2500\u2500 Elbow (1 DOF)\n\u2502   \u251c\u2500\u2500 Wrist (2-3 DOF)\n\u2502   \u2514\u2500\u2500 Hand (variable DOF)\n\u251c\u2500\u2500 Right Arm Chain\n\u2502   \u251c\u2500\u2500 Shoulder (3 DOF)\n\u2502   \u251c\u2500\u2500 Elbow (1 DOF)\n\u2502   \u251c\u2500\u2500 Wrist (2-3 DOF)\n\u2502   \u2514\u2500\u2500 Hand (variable DOF)\n\u2514\u2500\u2500 Head/Neck Chain\n    \u251c\u2500\u2500 Neck (2-3 DOF: pitch, yaw, optional roll)\n    \u2514\u2500\u2500 Eyes (optional DOF for gaze control)\n"})}),"\n",(0,o.jsx)(e.h2,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Forward kinematics calculates the position and orientation of end-effectors (hands, feet) given joint angles."}),"\n",(0,o.jsx)(e.h3,{id:"mathematical-foundation",children:"Mathematical Foundation"}),"\n",(0,o.jsx)(e.p,{children:"For each kinematic chain, forward kinematics can be expressed as:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"T = T_base * A_1(\u03b8_1) * A_2(\u03b8_2) * ... * A_n(\u03b8_n)\n"})}),"\n",(0,o.jsx)(e.p,{children:"Where:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"T"})," is the transformation matrix from base to end-effector"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"T_base"})," is the base transformation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"A_i(\u03b8_i)"})," is the transformation matrix for joint i as a function of angle \u03b8_i"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import numpy as np\nfrom math import sin, cos\n\nclass HumanoidFK:\n    def __init__(self):\n        # Link lengths for a simplified humanoid model\n        self.l_upper_leg = 0.45  # meters\n        self.l_lower_leg = 0.45  # meters\n        self.l_upper_arm = 0.35  # meters\n        self.l_lower_arm = 0.35  # meters\n    \n    def rotation_matrix(self, angle, axis):\n        \"\"\"Create rotation matrix for a given angle around an axis\"\"\"\n        if axis == 'x':\n            return np.array([\n                [1, 0, 0],\n                [0, cos(angle), -sin(angle)],\n                [0, sin(angle), cos(angle)]\n            ])\n        elif axis == 'y':\n            return np.array([\n                [cos(angle), 0, sin(angle)],\n                [0, 1, 0],\n                [-sin(angle), 0, cos(angle)]\n            ])\n        elif axis == 'z':\n            return np.array([\n                [cos(angle), -sin(angle), 0],\n                [sin(angle), cos(angle), 0],\n                [0, 0, 1]\n            ])\n    \n    def transform_matrix(self, angle, axis, translation):\n        \"\"\"Create transformation matrix combining rotation and translation\"\"\"\n        R = self.rotation_matrix(angle, axis)\n        T = np.eye(4)\n        T[:3, :3] = R\n        T[:3, 3] = translation\n        return T\n    \n    def leg_forward_kinematics(self, hip_angles, knee_angle, ankle_angles, leg_length=None):\n        \"\"\"\n        Calculate leg forward kinematics\n        hip_angles: [hip_yaw, hip_pitch, hip_roll]\n        knee_angle: knee flexion angle\n        ankle_angles: [ankle_pitch, ankle_roll]\n        \"\"\"\n        if leg_length is None:\n            upper_len = self.l_upper_leg\n            lower_len = self.l_lower_leg\n        else:\n            upper_len, lower_len = leg_length\n        \n        # Base transformation (relative to body)\n        T_base = np.eye(4)  # Simplified as identity\n        \n        # Hip joint transformations\n        T_hip_yaw = self.transform_matrix(hip_angles[0], 'z', [0, 0, 0])\n        T_hip_pitch = self.transform_matrix(hip_angles[1], 'y', [0, 0, 0])\n        T_hip_roll = self.transform_matrix(hip_angles[2], 'x', [0, 0, 0])\n        \n        # Upper leg (translation only)\n        T_upper_leg = self.transform_matrix(0, 'z', [0, 0, -upper_len])\n        \n        # Knee joint\n        T_knee = self.transform_matrix(knee_angle, 'y', [0, 0, 0])\n        \n        # Lower leg (translation only)\n        T_lower_leg = self.transform_matrix(0, 'z', [0, 0, -lower_len])\n        \n        # Ankle angles\n        T_ankle_pitch = self.transform_matrix(ankle_angles[0], 'y', [0, 0, 0])\n        T_ankle_roll = self.transform_matrix(ankle_angles[1], 'x', [0, 0, 0])\n        \n        # Combine all transformations\n        T_total = (T_base @ T_hip_yaw @ T_hip_pitch @ T_hip_roll @ \n                  T_upper_leg @ T_knee @ T_lower_leg @ \n                  T_ankle_pitch @ T_ankle_roll)\n        \n        return T_total\n    \n    def arm_forward_kinematics(self, shoulder_angles, elbow_angle, wrist_angles, arm_length=None):\n        \"\"\"\n        Calculate arm forward kinematics\n        shoulder_angles: [shoulder_yaw, shoulder_pitch, shoulder_roll]\n        elbow_angle: elbow flexion angle\n        wrist_angles: [wrist_yaw, wrist_pitch, wrist_roll]\n        \"\"\"\n        if arm_length is None:\n            upper_len = self.l_upper_arm\n            lower_len = self.l_lower_arm\n        else:\n            upper_len, lower_len = arm_length\n        \n        # Base transformation (relative to body)\n        T_base = np.eye(4)  # Simplified as identity\n        \n        # Shoulder joint transformations\n        T_shoulder_yaw = self.transform_matrix(shoulder_angles[0], 'z', [0, 0, 0])\n        T_shoulder_pitch = self.transform_matrix(shoulder_angles[1], 'y', [0, 0, 0])\n        T_shoulder_roll = self.transform_matrix(shoulder_angles[2], 'x', [0, 0, 0])\n        \n        # Upper arm (translation only)\n        T_upper_arm = self.transform_matrix(0, 'y', [0, 0, -upper_len])\n        \n        # Elbow joint\n        T_elbow = self.transform_matrix(elbow_angle, 'y', [0, 0, 0])\n        \n        # Lower arm (translation only)\n        T_lower_arm = self.transform_matrix(0, 'y', [0, 0, -lower_len])\n        \n        # Wrist angles\n        T_wrist_yaw = self.transform_matrix(wrist_angles[0], 'z', [0, 0, 0])\n        T_wrist_pitch = self.transform_matrix(wrist_angles[1], 'y', [0, 0, 0])\n        T_wrist_roll = self.transform_matrix(wrist_angles[2], 'x', [0, 0, 0])\n        \n        # Combine all transformations\n        T_total = (T_base @ T_shoulder_yaw @ T_shoulder_pitch @ T_shoulder_roll @ \n                  T_upper_arm @ T_elbow @ T_lower_arm @ \n                  T_wrist_yaw @ T_wrist_pitch @ T_wrist_roll)\n        \n        return T_total\n"})}),"\n",(0,o.jsx)(e.h3,{id:"whole-body-forward-kinematics",children:"Whole-Body Forward Kinematics"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class WholeBodyFK:\n    def __init__(self):\n        self.left_arm_fk = HumanoidFK()\n        self.right_arm_fk = HumanoidFK()\n        self.left_leg_fk = HumanoidFK()\n        self.right_leg_fk = HumanoidFK()\n    \n    def calculate_all_end_effectors(self, joint_angles):\n        \"\"\"\n        Calculate positions of all end-effectors given joint angles\n        joint_angles: dictionary with joint names and angles\n        \"\"\"\n        results = {}\n        \n        # Calculate left arm end-effector (left hand)\n        left_shoulder = [\n            joint_angles.get('left_shoulder_yaw', 0),\n            joint_angles.get('left_shoulder_pitch', 0), \n            joint_angles.get('left_shoulder_roll', 0)\n        ]\n        left_elbow = joint_angles.get('left_elbow', 0)\n        left_wrist = [\n            joint_angles.get('left_wrist_yaw', 0),\n            joint_angles.get('left_wrist_pitch', 0),\n            joint_angles.get('left_wrist_roll', 0)\n        ]\n        \n        T_left_hand = self.left_arm_fk.arm_forward_kinematics(\n            left_shoulder, left_elbow, left_wrist\n        )\n        results['left_hand'] = T_left_hand\n        \n        # Calculate right arm end-effector (right hand)\n        right_shoulder = [\n            joint_angles.get('right_shoulder_yaw', 0),\n            joint_angles.get('right_shoulder_pitch', 0),\n            joint_angles.get('right_shoulder_roll', 0)\n        ]\n        right_elbow = joint_angles.get('right_elbow', 0)\n        right_wrist = [\n            joint_angles.get('right_wrist_yaw', 0),\n            joint_angles.get('right_wrist_pitch', 0), \n            joint_angles.get('right_wrist_roll', 0)\n        ]\n        \n        T_right_hand = self.right_arm_fk.arm_forward_kinematics(\n            right_shoulder, right_elbow, right_wrist\n        )\n        results['right_hand'] = T_right_hand\n        \n        # Calculate left leg end-effector (left foot)\n        left_hip = [\n            joint_angles.get('left_hip_yaw', 0),\n            joint_angles.get('left_hip_pitch', 0),\n            joint_angles.get('left_hip_roll', 0)\n        ]\n        left_knee = joint_angles.get('left_knee', 0)\n        left_ankle = [\n            joint_angles.get('left_ankle_pitch', 0),\n            joint_angles.get('left_ankle_roll', 0)\n        ]\n        \n        T_left_foot = self.left_leg_fk.leg_forward_kinematics(\n            left_hip, left_knee, left_ankle\n        )\n        results['left_foot'] = T_left_foot\n        \n        # Calculate right leg end-effector (right foot)\n        right_hip = [\n            joint_angles.get('right_hip_yaw', 0),\n            joint_angles.get('right_hip_pitch', 0),\n            joint_angles.get('right_hip_roll', 0)\n        ]\n        right_knee = joint_angles.get('right_knee', 0)\n        right_ankle = [\n            joint_angles.get('right_ankle_pitch', 0),\n            joint_angles.get('right_ankle_roll', 0)\n        ]\n        \n        T_right_foot = self.right_leg_fk.leg_forward_kinematics(\n            right_hip, right_knee, right_ankle\n        )\n        results['right_foot'] = T_right_foot\n        \n        return results\n"})}),"\n",(0,o.jsx)(e.h2,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Inverse kinematics calculates the required joint angles to achieve desired end-effector positions and orientations. This is more complex than forward kinematics and often requires iterative or analytical solutions."}),"\n",(0,o.jsx)(e.h3,{id:"analytical-ik-for-arms",children:"Analytical IK for Arms"}),"\n",(0,o.jsx)(e.p,{children:"For simple arm configurations, analytical solutions exist:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import math\n\nclass AnalyticalArmIK:\n    def __init__(self, upper_arm_length=0.35, lower_arm_length=0.35):\n        self.l1 = upper_arm_length  # Upper arm length\n        self.l2 = lower_arm_length  # Lower arm length\n    \n    def solve_3dof_arm(self, target_position, shoulder_position=[0, 0, 0]):\n        """\n        Solve inverse kinematics for a simplified 3-DOF arm\n        Assumes shoulder at origin, with 1 DOF in each of x, y, z planes\n        target_position: [x, y, z] in global coordinates\n        """\n        # Transform target to shoulder-centered coordinates\n        x = target_position[0] - shoulder_position[0]\n        y = target_position[1] - shoulder_position[1]\n        z = target_position[2] - shoulder_position[2]\n        \n        # Calculate distance from shoulder to target\n        r = math.sqrt(x**2 + y**2)\n        d = math.sqrt(r**2 + z**2)\n        \n        # Check if target is reachable\n        if d > (self.l1 + self.l2):\n            print(f"Target unreachable: {target_position}")\n            return None  # Target too far\n        elif d < abs(self.l1 - self.l2):\n            print(f"Target unreachable: inside workspace")\n            return None  # Target too close\n        \n        # Calculate joint angles using law of cosines\n        # Angle at shoulder\n        cos_shoulder = (self.l1**2 + d**2 - self.l2**2) / (2 * self.l1 * d)\n        angle_shoulder = math.acos(max(-1, min(1, cos_shoulder)))  # Clamp to valid range\n        \n        # Angle at elbow\n        cos_elbow = (self.l1**2 + self.l2**2 - d**2) / (2 * self.l1 * self.l2)\n        angle_elbow = math.pi - math.acos(max(-1, min(1, cos_elbow)))\n        \n        # Shoulder azimuth (rotation about z-axis)\n        azimuth = math.atan2(y, x)\n        \n        # Shoulder elevation (rotation about y-axis)\n        elevation = math.atan2(z, r)\n        \n        # Calculate final joint angles\n        shoulder_yaw = azimuth\n        shoulder_pitch = elevation + angle_shoulder\n        elbow_angle = angle_elbow\n        \n        return {\n            \'shoulder_yaw\': shoulder_yaw,\n            \'shoulder_pitch\': shoulder_pitch, \n            \'elbow_angle\': elbow_angle\n        }\n\n# Example usage\narm_ik = AnalyticalArmIK()\ntarget = [0.5, 0.0, 0.3]  # 50cm forward, 0cm sideways, 30cm up\njoint_angles = arm_ik.solve_3dof_arm(target)\n\nif joint_angles:\n    print(f"Shoulder Yaw: {joint_angles[\'shoulder_yaw\']:.3f}")\n    print(f"Shoulder Pitch: {joint_angles[\'shoulder_pitch\']:.3f}")\n    print(f"Elbow Angle: {joint_angles[\'elbow_angle\']:.3f}")\n'})}),"\n",(0,o.jsx)(e.h3,{id:"iterative-ik-for-complex-chains",children:"Iterative IK for Complex Chains"}),"\n",(0,o.jsx)(e.p,{children:"For more complex chains like full arms or legs, iterative methods are more practical:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom scipy.optimize import minimize\n\nclass IterativeIK:\n    def __init__(self, fk_solver, max_iterations=100, tolerance=1e-4):\n        self.fk_solver = fk_solver\n        self.max_iterations = max_iterations\n        self.tolerance = tolerance\n    \n    def jacobian_transpose_method(self, initial_joints, target_position, \n                                  end_effector_func, joint_limits=None):\n        """\n        Solve inverse kinematics using Jacobian transpose method\n        """\n        current_joints = np.array(initial_joints)\n        \n        for iteration in range(self.max_iterations):\n            # Calculate current end-effector position\n            current_pos = end_effector_func(current_joints)\n            \n            # Calculate error\n            error = target_position - current_pos\n            error_norm = np.linalg.norm(error)\n            \n            # Check if we\'ve reached the target\n            if error_norm < self.tolerance:\n                print(f"Reached target at iteration {iteration}")\n                break\n            \n            # Calculate Jacobian (simplified finite difference)\n            jacobian = self.calculate_jacobian(current_joints, end_effector_func)\n            \n            # Update joint angles using Jacobian transpose\n            joint_delta = 0.01 * jacobian.T @ error  # Learning rate * J^T * error\n            current_joints += joint_delta\n            \n            # Apply joint limits if provided\n            if joint_limits:\n                for i, (min_limit, max_limit) in enumerate(joint_limits):\n                    current_joints[i] = np.clip(current_joints[i], min_limit, max_limit)\n        \n        return current_joints, error_norm, iteration\n    \n    def calculate_jacobian(self, joints, end_effector_func, delta_q=1e-5):\n        """\n        Calculate Jacobian matrix using finite differences\n        """\n        n_joints = len(joints)\n        \n        # Get current end-effector position\n        current_pos = end_effector_func(joints)\n        \n        # Initialize Jacobian (3xN for position only, 6xN for pose)\n        jacobian = np.zeros((3, n_joints))\n        \n        # Calculate each column of Jacobian\n        for i in range(n_joints):\n            # Perturb joint i\n            joints_plus = joints.copy()\n            joints_minus = joints.copy()\n            joints_plus[i] += delta_q\n            joints_minus[i] -= delta_q\n            \n            # Calculate end-effector positions\n            pos_plus = end_effector_func(joints_plus)\n            pos_minus = end_effector_func(joints_minus)\n            \n            # Calculate Jacobian column (partial derivatives)\n            jacobian[:, i] = (pos_plus - pos_minus) / (2 * delta_q)\n        \n        return jacobian\n\n# Example usage with a mock forward kinematics function\ndef mock_arm_fk(joint_angles):\n    """\n    Mock forward kinematics for demonstration\n    Simplified model: x = l1*cos(q1) + l2*cos(q1+q2)\n                     y = l1*sin(q1) + l2*sin(q1+q2)\n    """\n    l1, l2 = 0.35, 0.35  # Arm lengths\n    q1, q2 = joint_angles[0], joint_angles[1]\n    \n    x = l1 * np.cos(q1) + l2 * np.cos(q1 + q2)\n    y = l1 * np.sin(q1) + l2 * np.sin(q1 + q2)\n    \n    # Return 3D position (z=0 for planar arm)\n    return np.array([x, y, 0])\n\n# Solve IK problem\nik_solver = IterativeIK(mock_arm_fk)\ninitial_joints = [0.1, 0.1]  # Initial joint angles\ntarget = np.array([0.4, 0.3, 0.0])  # Target position\n\nfinal_joints, final_error, iterations = ik_solver.jacobian_transpose_method(\n    initial_joints, target, mock_arm_fk\n)\n\nprint(f"Final joints: {final_joints}")\nprint(f"Final error: {final_error}")\nprint(f"Iterations: {iterations}")\n'})}),"\n",(0,o.jsx)(e.h2,{id:"center-of-mass-calculation",children:"Center of Mass Calculation"}),"\n",(0,o.jsx)(e.p,{children:"The center of mass (CoM) is critical for humanoid robot balance:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class CenterOfMassCalculator:\n    def __init__(self):\n        # Define link masses and positions relative to joint frames\n        self.link_properties = {\n            # Format: [mass in kg, [x, y, z] com offset from joint in meters]\n            'trunk': [15.0, [0.0, 0.0, 0.1]],  # torso\n            'head': [3.0, [0.0, 0.0, 0.05]],   # head\n            'left_upper_arm': [2.0, [0.0, 0.0, -0.175]],  # upper arm\n            'left_lower_arm': [1.5, [0.0, 0.0, -0.175]],  # lower arm\n            'right_upper_arm': [2.0, [0.0, 0.0, -0.175]],\n            'right_lower_arm': [1.5, [0.0, 0.0, -0.175]],\n            'left_upper_leg': [5.0, [0.0, 0.0, -0.225]],  # upper leg\n            'left_lower_leg': [4.0, [0.0, 0.0, -0.225]],  # lower leg\n            'right_upper_leg': [5.0, [0.0, 0.0, -0.225]],\n            'right_lower_leg': [4.0, [0.0, 0.0, -0.225]],\n            'left_foot': [1.0, [0.1, 0.0, -0.05]],  # foot\n            'right_foot': [1.0, [0.1, 0.0, -0.05]]\n        }\n    \n    def calculate_com(self, fk_results, trunk_pose):\n        \"\"\"\n        Calculate overall center of mass\n        fk_results: results from forward kinematics\n        trunk_pose: pose of the trunk (base of robot)\n        \"\"\"\n        total_mass = 0.0\n        weighted_positions = np.array([0.0, 0.0, 0.0])\n        \n        # Calculate CoM for each link\n        for link_name, (mass, local_com_offset) in self.link_properties.items():\n            # Get the transform for this link\n            if link_name in fk_results:\n                T = fk_results[link_name]\n                # Calculate CoM position in global frame\n                local_com = np.array(local_com_offset + [1])  # homogeneous coordinates\n                global_com = T @ local_com\n                global_com_pos = global_com[:3]  # Remove homogeneous coordinate\n            else:\n                # For trunk, use its pose directly\n                if link_name == 'trunk':\n                    # Calculate trunk CoM from its pose\n                    T_trunk = np.eye(4)  # Identity for trunk base\n                    T_trunk[:3, :3] = self.rotation_from_pose(trunk_pose['orientation'])\n                    T_trunk[:3, 3] = trunk_pose['position']\n                    \n                    local_com = np.array(local_com_offset + [1])\n                    global_com = T_trunk @ local_com\n                    global_com_pos = global_com[:3]\n                else:\n                    # If link not in FK results, skip (e.g., trunk handled separately)\n                    continue\n            \n            # Add to weighted sum\n            weighted_positions += mass * global_com_pos\n            total_mass += mass\n        \n        if total_mass > 0:\n            overall_com = weighted_positions / total_mass\n        else:\n            overall_com = np.array([0.0, 0.0, 0.0])\n        \n        return overall_com, total_mass\n    \n    def rotation_from_pose(self, orientation_quat):\n        \"\"\"Convert quaternion to rotation matrix\"\"\"\n        x, y, z, w = orientation_quat\n        \n        # Convert quaternion to rotation matrix\n        R = np.array([\n            [1 - 2*(y**2 + z**2), 2*(x*y - w*z), 2*(x*z + w*y)],\n            [2*(x*y + w*z), 1 - 2*(x**2 + z**2), 2*(y*z - w*x)],\n            [2*(x*z - w*y), 2*(y*z + w*x), 1 - 2*(x**2 + y**2)]\n        ])\n        \n        return R\n"})}),"\n",(0,o.jsx)(e.h2,{id:"practical-considerations",children:"Practical Considerations"}),"\n",(0,o.jsx)(e.h3,{id:"joint-limits-and-constraints",children:"Joint Limits and Constraints"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class JointConstraintHandler:\n    def __init__(self):\n        # Define joint limits for a typical humanoid robot\n        self.joint_limits = {\n            # Hip joints\n            'left_hip_yaw': (-0.7, 0.7),      # ~\xb140 degrees\n            'left_hip_pitch': (-0.4, 1.0),    # ~-23 to +57 degrees\n            'left_hip_roll': (-0.4, 0.4),     # ~\xb123 degrees\n            'right_hip_yaw': (-0.7, 0.7),\n            'right_hip_pitch': (-0.4, 1.0),\n            'right_hip_roll': (-0.4, 0.4),\n            \n            # Knee joints\n            'left_knee': (0.0, 2.3),          # ~0 to +132 degrees (flexion only)\n            'right_knee': (0.0, 2.3),\n            \n            # Ankle joints\n            'left_ankle_pitch': (-0.4, 0.7),  # ~-23 to +40 degrees\n            'left_ankle_roll': (-0.4, 0.4),\n            'right_ankle_pitch': (-0.4, 0.7),\n            'right_ankle_roll': (-0.4, 0.4),\n            \n            # Shoulder joints\n            'left_shoulder_yaw': (-1.57, 1.57),    # ~\xb190 degrees\n            'left_shoulder_pitch': (-2.0, 1.0),    # ~-115 to +57 degrees\n            'left_shoulder_roll': (-2.0, 1.0),\n            'right_shoulder_yaw': (-1.57, 1.57),\n            'right_shoulder_pitch': (-2.0, 1.0),\n            'right_shoulder_roll': (-1.0, 2.0),\n            \n            # Elbow joints\n            'left_elbow': (0.0, 2.5),          # ~0 to +143 degrees (flexion only)\n            'right_elbow': (0.0, 2.5),\n            \n            # Wrist joints\n            'left_wrist_yaw': (-0.7, 0.7),     # ~\xb140 degrees\n            'left_wrist_pitch': (-0.7, 0.7),\n            'right_wrist_yaw': (-0.7, 0.7),\n            'right_wrist_pitch': (-0.7, 0.7)\n        }\n    \n    def check_joint_limits(self, joint_angles):\n        \"\"\"Check if joint angles are within limits\"\"\"\n        violations = []\n        \n        for joint_name, angle in joint_angles.items():\n            if joint_name in self.joint_limits:\n                min_limit, max_limit = self.joint_limits[joint_name]\n                \n                if angle < min_limit or angle > max_limit:\n                    violations.append({\n                        'joint': joint_name,\n                        'angle': angle,\n                        'min_limit': min_limit,\n                        'max_limit': max_limit\n                    })\n        \n        return len(violations) == 0, violations\n    \n    def apply_joint_limits(self, joint_angles):\n        \"\"\"Apply joint limits by clipping values\"\"\"\n        limited_angles = joint_angles.copy()\n        \n        for joint_name, angle in joint_angles.items():\n            if joint_name in self.joint_limits:\n                min_limit, max_limit = self.joint_limits[joint_name]\n                limited_angles[joint_name] = np.clip(angle, min_limit, max_limit)\n        \n        return limited_angles\n"})}),"\n",(0,o.jsx)(e.h2,{id:"hands-on-exercise",children:"Hands-on Exercise"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Implement a complete forward kinematics solver for a simplified humanoid model with 12 DOF (6 per leg)."}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Create an inverse kinematics solver that can position a humanoid robot's foot at a given location."}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Using the educational AI, explore how kinematic constraints affect the range of motion in humanoid robots."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"The next section will explore the dynamics of humanoid robots, including how forces affect their motion."})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>r});var t=i(6540);const o={},a=t.createContext(o);function l(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:l(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);